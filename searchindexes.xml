<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>Rust基本数据类型</title><url>/posts/rust%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url><categories/><tags><tag>rust</tag><tag>编程语言</tag></tags><content type="html"><![CDATA[类型系统 什么是类型 减少开发者心智负担 安全 容易优化 常见的类型分类 静态类型，在编译阶段对类型进行检查 动态类型， 在运行期间对类型进行检查 强类型，不允许隐式类型转换 (pyhon是动态强类型) 弱类型，允许进行隐式类型转换 c语言由于允许隐式类型转换因此是静态弱类型
int main() { long a = 10; return a; } rust是静态强类型
变量和可变性 创建和使用变量 在rust中可以使用let关键字进行变量赋值
fn main() { let x=5; println!(&#34;the value of x is {}&#34;, x); } 在rust中变量默认不可变
fn main() { let x=5; println!(&#34;the value of x is {}&#34;, x); x = 6; println!(&#34;the value of x is {}&#34;, x); } 在创建变量前增加mut使得变量可变
fn main() { let mut x=5; println!(&#34;the value of x is {}&#34;, x); x = 6; println!(&#34;the value of x is {}&#34;, x); } 常量和不可变变量
常量使用const关键字 可以在任何位置定义
const A_CONST: i32= 42; fn main() { let mut x=5; println!(&#34;the value of x is {}&#34;, x); x = 6; println!(&#34;the value of x is {}&#34;, x); println!(&#34;the value of x is {}&#34;, A_CONST); } 常量在编译期间进行求值，不可变变量是在运行期期间进行求值
const A_CONST: i32= 42 + 2 - 1 //常量表达式 在编译期求值 const A_CONST: i32= get_number(); //不能将一个函数的返回值作为常量 fn get_number() -&gt; i32 { 42 } fn main() { let r = get_number(); // 函数的返回值可以作为一个不可变变量的值 println!(&#34;the value of x is {}&#34;, r); } 变量的隐藏 shadowing
可以声明与前一个变量同名的新变量, 新变量会隐藏前一个变量
fn main() { let x = 5; let x= x+1; let x = x * 2; println!(&#34;{}&#34;, x); } // 推荐使用上面的隐藏的写法 fn main() { let mut x = 5; x= x+1; x = x * 2; println!(&#34;{}&#34;, x); } 基础数据类型 由于rust是一门静态编程语言
整数 rust有12种不同的整数类型
长度 有符号 无符号 8 bit i8 u8 16 bit i16 u16 32 bit i32 u32 64 bit i64 u64 128 bit i128 u128 arch isize usize 对于未明确标注类型的整数，rust默认使用i32
isize和usize根据系统的不同而有不同的长度
如果只是一个正的数字推荐使用无符号，否则使用有符号
浮点数 rust有两种浮点数类型为f32和f64, 后者的精度更加高
对于未明确标注类型的小数， rust默认使用f64
fn main() { let x = 2.0; // f64 let y: f32 = 3.0; // f32 } 布尔值 与大多数其他编程语言一样，rust的布尔值有两个可能的值， true和false, 大小均为一个字节
fn main() { let t = true; let f: bool = false; } 字符 rust支持单个字符，字符使用单引号包装
fn main() { let c = &#39;z&#39;; let z = &#39;ℤ&#39;; let heart_eyed_cat = &#39;😻&#39;; println!(&#34;{} {} {}&#34;, c, z, heart_eyed_cat) } 例题 编写一个函数，它接受两个u32类型的参数，并且返回其平均数，ps 考虑其整数溢出的问题 下面是用例
fn main() { assert_eq!(avg(4294967295, 4294967295), 4294967295); assert_eq!(avg(0, 0), 0); assert_eq!(avg(10, 20), 15); assert_eq!(avg(4294967295, 1), 2147483648); println!(&#34;passed&#34;) } fn avg(a: u32, b: u32) -&gt; u32{ (a &amp; b) + ((a ^ b) &gt;&gt; 1 ) } 整数溢出 在电脑领域里所发生的溢出条件是, 运行单项数值计算时, 当计算产生出来的结果是非常大的, 大于寄存器或存储器所能存储或表示的能力限制就会发生溢出.
在不同的编程语言中, 对待溢出通常有以下几种不同的做法:
崩溃: 当溢出被侦测到时, 程序立即退出运行 忽略: 这是最普遍的作法, 忽略任何算数溢出 对于溢出的处理方法, Rust 在 debug 与 release 模式下是不同的. 在 debug 模式下编译时, Rust 会检查整数溢出, 如果发生这种行为, 会导致程序在运行时终止并报出运行时错误. 而如果在 release 模式下编译时, Rust 不会对整数溢出进行检查.
要显式处理溢出, 可以使用标准库提供的一些 .overflowing_* 方法:
fn main() { let a: u32 = 4294967295; let b: u32 = 1; let (r, is_overflow) = a.overflowing_add(b); println!(&#34;r={} is_overflow={}&#34;, r, is_overflow); } 元组 元组是将多个具有各种类型的值组合成一个复合类型的通用方法，元组有固定长度，一旦声明，他们的大小就不能增长或者收缩。
通过在括号内写一个逗号分隔的值列表来创建一个元组，元组中的每个位置都有一个类型，元组中不同值的类型不必相同.
fn main() { let a: i32 = 10; let b: char = &#39;A&#39;; // 创建一个元组 let mytuple: (i32, char) = (a, b); // 从元组中读取一个值 println!(&#34;.0={:?}&#34;, mytuple.0); println!(&#34;.1={:?}&#34;, mytuple.1); // 解封装 let (c, d) = mytuple; println!(&#34;c={} d={}&#34;, c, d); } 数组 rust中另一种具有多个数据集合的方法是数组，与元组不同，数据的每一个元素的类型都必须相同，rust中的数组不同于其他的语言，rust的数据足有固定的长度。
数组的下标以0开始，同时rust存在越界检查。
fn main() { // 创建数组, [i32; 3] 是数组的类型提示, 表示元素的类型是 i32, 共有 3 个元素 let myarray: [i32; 3] = [1, 2, 3]; // 根据索引获取一个值, 数组下标从 0 开始 println!(&#34;{:?}&#34;, myarray[1]); //:?也可以不写 // 索引不能越界 println!(&#34;{:?}&#34;, myarray[3]); // 如果数组的每个元素都有相同的值, 我们还可以简化数组的初始化 let myarray: [i32; 3] = [0; 3]; println!(&#34;{:?}&#34;, myarray[1]); } 切片类型 切片类型是对一个数组(包括固定大小数组和动态数组)的引用片段, 有利于安全有效地访问数组的一部分, 而不需要拷贝数组或数组中的内容. 切片在编译的时候其长度是未知的, 在底层实现上, 一个切片保存着两个 uszie 成员, 第一个 usize 成员指向切片起始位置的指针, 第二个 usize 成员表示切片长度.
fn main() { let arr: [i32; 5] = [1, 2, 3, 4, 5]; let slice = &amp;arr[0..3]; // 取前 3 个元素 println!(&#34;slice[0]={}, len={}&#34;, slice[0], slice.len()); } 结构体 结构体是多种不同数据类型的组合. 它与元组类似, 但区别在于我们可以为每个成员命名. 可以使用 struct 关键字创建三种类型的结构:
元组结构 经典的 C 结构 无字段的单元结构 结构体使用驼峰命名.
// 元组结构 struct Pair(i32, f32); // 经典的 C 结构 struct Person { name: String, age: u8, } // 无字段的单元结构, 在泛型中较为常用 struct Unit; fn main() { // 结构体的实例化 let pair = Pair(10, 4.2); let person = Persion { name: String::from(&#34;jack&#34;), age: 21, }; let unit = Unit; // 从结构体中获取成员 println!(&#34;{}&#34;, pari.0); println!(&#34;{}&#34;, persion.name); } ]]></content></entry><entry><title>数组链表栈和队列</title><url>/posts/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url><categories/><tags/><content type="html">知识点 数组 连续的存储空间 一次性定位（通过index） 快速定位查找，插入删除 较差 链表 离散的存储空间 通过next节点定位下一个list node 删除， 插入相对简单； 查找相对数组复杂（除了头节点外) 栈 stack 先进后出的数据结构（类似杯子只有一个出口) 队列 先进先出的数据结构 （类似排队) 练习题 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。
示例 1：
输入：digits = [1,2,3] 输出：[1,2,4] 解释：输入数组表示数字 123。 示例 2：
输入：digits = [4,3,2,1] 输出：[4,3,2,2] 解释：输入数组表示数字 4321。 示例 3：
输入：digits = [0] 输出：[1] 分析：
数组假定为数字 1+1 = 2 9+1 = 10 99+1 = 100 从最后一个数字开始遍历 最后一位加一 剩余的加上进位 需要一个变量存储进位</content></entry><entry><title>Nginx Upstream Oss</title><url>/posts/nginx-upstream-oss/</url><categories/><tags><tag>nginx</tag><tag>oss</tag></tags><content type="html">需求 私有部署的前端资源均由前端nodejs服务直接返回，同时也没有相关缓存的配置，导致请求会占用比较多的服务器带宽资源，计划将资源全部切换到对象存储中使用cdn回源的方式来进行访问。 这样做既可以减少带宽的使用，同时也可以借助cdn更好的用户接入点来优化访问速度。
实施 切换oss 和业务沟通后支持nodejs服务直接将资源相对路径拼接阿里oss地址， 阿里云在当地尚未上线cdn所以直接使用oss 公共读平替，上线到测试环境观察一段时间后。反馈服务器带宽资源有降低， 但是用户的的访问效果依旧不太好， 还是有反馈很慢的情况。 检查后发现阿里云oss默认使用http 1.1进行返回, 同时还有很多未使用缓存的情况，与阿里云售后确认oss不能直接使用http2, 除非绑定对应cdn。
在确认cdn上线时间未知后，计划在oss上将对应的文件均配置为一年的缓存策略。
ossutil set-meta oss://public/ Cache-Control:max-age=31536000 -r --update 跨域的坑 既然切换了对象存储使用公开读的方式，那么跨域配置也就是必要的了，在对应oss上配置了 AllowedOrigin: * AllowedMethod: GET HEAD 的对应规则，配置好后一段时间风平浪静~~~
大概过了几天有用户和测试反馈说有页面无法打开，chrome调试窗口看发现有资源出现了跨域的告警。前端同事远程后发现静态资源的相应头少了 access-control-allow-origin: * 这个header， oss也不支持全部请求都返回这个header除非使用cdn。重新沟通后计划使用nginx做一层代理来进行header的添加和修改。
proxy_set_header Origin &amp;#39;https://xxx.com&amp;#39;; #对应来源域名 proxy_hide_header access-control-allow-methods; proxy_hide_header access-control-expose-headers; proxy_pass: oss地址 header 里面 access-control 相关的 header 只能带 access-control-allow-origin: * ，带上其他的就会影响缓存响应时的 header ，一样会导致 cors error，因为读取缓存的时候 header 里没有带 access-control-allow-origin: *</content></entry><entry><title>Minio纠删码</title><url>/posts/minio%E7%BA%A0%E5%88%A0%E7%A0%81/</url><categories/><tags><tag>minio</tag><tag>对象存储</tag></tags><content type="html">数据可靠性的方案 冗余 多副本 多副本一般就是一份数据存储多份，并且每份数据都保存在不用的服务器或者跨机房，地域。 通常情况下副本一般是3个， 大约是11个9的可靠性。 ps:
我有3个文件，每个文件都大约是1g。 按照三个副本的方式复制3份，然后放在不同的服务器上进行保存。这种3副本的策略下, 总的存储冗余度是 300% 空间浪费是200%。
当然有些时候为了降低成本, 只存储2个副本, 这时冗余度是200%, 也有了1倍的存储空间浪费。
服务器1 服务器2 服务器3 Data1 Data1 Data1 Data2 Data2 Data2 Data3 Data3 Data3 纠删码基本原理 K+1的冗余实现 有三个自然数，做到记录四个数字实现任意一个数字丢失都可以被找回。
解： 记录这三个数字之和即可实现这个需求
$$ y_{1} = x_{1} + x_{2} + x_{3} $$
如果 $$ x_{2} $$
丢失后只需要
$$ x_{2} = y_{1} - x_{1} - x_{3} $$
即可求出对应的值，如果是y丢失了，只需要重新计算对应的和即可。
在这个方案下一共存储了4份数据，其中实际有效的数据是3份， 冗余133%， 基本实现了和2副本类似的可靠性。这个方式和日常使用的raid5基本一致，raid5同样是计算一份校验和的数据进行存储，并且允许一块坏掉后进行恢复。
存储策略 冗余 可靠性 两副本 200% 允许丢一块 3+1冗余 133% 允许丢一块 K+2的冗余实现 在上面多一个数字存储的情况下，再加一个数字的存储来实现，丢失任意两个数字可以实现找回。
解： 在k+1的实现中，是给所有的数据块和校验块构建了一个求和的关系来进行关联。
$$ y_{1} = x_{1} + x_{2} + x_{3} $$
现在想要增加可以丢失的数据块，不能单纯的进行存两次和来实现。
$$ y_{1} = x_{1} + x_{2} + x_{3} $$
$$ y_{2} = x_{1} + x_{2} + x_{3} $$
$$ y_{2} = y_{1} $$
* 存储 $$ y_{1} ,y_{2}, x_{1},x_{2},x_{3} $$
5个数字 * 当需要恢复数据时，假设
$$ x_{1}, x_{2} $$
丢失了，那么下面这个线性方程是有无数个解的，我们无法从中计算出 丢失的两个数字是多少。这两个方程是一样的，基本没有什么求解的意义。
$$ x_{1} + x_{2} = y_{1} - x_{3} $$
$$ x_{1} + x_{2} = y_{2} - x_{3} $$
我们用一个简单的方案来让两个方程不一样，这样才会有解。在计算
$$ y_{2} $$
时我们给每个数据增加一个不同的系数。
* 计算 $$ y_{1} $$
时针对每个数字都乘以1 * 计算
$$ y_{2} $$
时针对每个数字都乘以
$$ 2^{0} \quad 2^{1} \quad 2^{2} \quad2^{3} $$
（系数规范可以自己定义）
$$ y_{1} = x_{1} + x_{2} + x_{3} $$
$$ y_{2} = 1 * x_{1} + 2 * x_{2} + 4 * x_{3} $$
存储过程仍旧是存储
$$ y_{1},
y_{2},
x_{1},
x_{2},
x_{3} $$
5个数字，当出现两个数据丢失时可以构建，下面的二元一次方程组。求解这个方程组，即可获取丢失的两个数据
$$ x_{1} , x_{2} $$
。以上这种加系数计算校验块的方式, 就是 RAID-6 的基本工作方式——为k个数据块之外再多存储2个校验数据, 当整个系统丢失2块数据时, 都可以找回。
$$ x_{1} + x_{2} = y_{1} - x_{3} $$
$$ x_{1} + 2x_{2} = y_{2} - 4x_{3} $$
有理数下k+2的EC的算法大概就出来了, 我们可以实现k+2的冗余策略, 通过166%的冗余, 实现差不多和三副本300%一样的可靠性。
K+M的冗余校验 如果需要增加更多的冗余来让纠删码实现类似4副本的可靠性 K+3， 那么只需要再增加一个校验块
$$ y_{3} $$
来实现。当我们计算新的
$$ y_{3} $$
时需要提供一个新的系数
$$ 3^{0} \quad 3^{1} \quad 3^{2} \quad 3^{3} $$
来保证当出现数据丢失时可以进行找回。
$$ y_{1} = x_{1} + x_{2} + x_{3} $$
$$ y_{2} = 1 * x_{1} + 2 * x_{2} + 4 * x_{3} $$
$$ y_{3} = 1 * x_{1} + 3 * x_{2} + 9 * x_{3} $$
如何进一步实现冗余，那么进一步增加新的系数，就可以实现恢复。
$$ y_{M} = z_{1} * x_{1} + z_{2} * x_{2} + z_{3} * x_{3} + &amp;hellip; + z_{m} * x_{M} $$
默认minio的ec比是数据盘和校验盘1：1， 冗余度是（实际数据+冗余数据）/实际数据， 按照石墨集群默认是6个节点3：3来看数据丢失的可能性大约是
$$ 2 * 10^{-15} $$</content></entry><entry><title>Hello World</title><url>/posts/hello-world/</url><categories/><tags><tag>hugo</tag></tags><content type="html">hello world this is my first notes.</content></entry></search>