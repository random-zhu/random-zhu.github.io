<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>Nginx Upstream Oss</title><url>/posts/nginx-upstream-oss/</url><categories/><tags><tag>nginx</tag><tag>oss</tag></tags><content type="html">需求 私有部署的前端资源均由前端nodejs服务直接返回，同时也没有相关缓存的配置，导致请求会占用比较多的服务器带宽资源，计划将资源全部切换到对象存储中使用cdn回源的方式来进行访问。 这样做既可以减少带宽的使用，同时也可以借助cdn更好的用户接入点来优化访问速度。
实施 切换oss 和业务沟通后支持nodejs服务直接将资源相对路径拼接阿里oss地址， 阿里云在当地尚未上线cdn所以直接使用oss 公共读平替，上线到测试环境观察一段时间后。反馈服务器带宽资源有降低， 但是用户的的访问效果依旧不太好， 还是有反馈很慢的情况。 检查后发现阿里云oss默认使用http 1.1进行返回, 同时还有很多未使用缓存的情况，与阿里云售后确认oss不能直接使用http2, 除非绑定对应cdn。
在确认cdn上线时间未知后，计划在oss上将对应的文件均配置为一年的缓存策略。
ossutil set-meta oss://public/ Cache-Control:max-age=31536000 -r --update 跨域的坑 既然切换了对象存储使用公开读的方式，那么跨域配置也就是必要的了，在对应oss上配置了 AllowedOrigin: * AllowedMethod: GET HEAD 的对应规则，配置好后一段时间风平浪静~~~
大概过了几天有用户和测试反馈说有页面无法打开，chrome调试窗口看发现有资源出现了跨域的告警。前端同事远程后发现静态资源的相应头少了 access-control-allow-origin: * 这个header， oss也不支持全部请求都返回这个header除非使用cdn。重新沟通后计划使用nginx做一层代理来进行header的添加和修改。
proxy_set_header Origin &amp;#39;https://xxx.com&amp;#39;; #对应来源域名 proxy_hide_header access-control-allow-methods; proxy_hide_header access-control-expose-headers; proxy_pass: oss地址 header 里面 access-control 相关的 header 只能带 access-control-allow-origin: * ，带上其他的就会影响缓存响应时的 header ，一样会导致 cors error，因为读取缓存的时候 header 里没有带 access-control-allow-origin: *</content></entry><entry><title>Minio纠删码</title><url>/posts/minio%E7%BA%A0%E5%88%A0%E7%A0%81/</url><categories/><tags><tag>minio</tag><tag>对象存储</tag></tags><content type="html">数据可靠性的方案 冗余 多副本 多副本一般就是一份数据存储多份，并且每份数据都保存在不用的服务器或者跨机房，地域。 通常情况下副本一般是3个， 大约是11个9的可靠性。 ps:
我有3个文件，每个文件都大约是1g。 按照三个副本的方式复制3份，然后放在不同的服务器上进行保存。这种3副本的策略下, 总的存储冗余度是 300% 空间浪费是200%。
当然有些时候为了降低成本, 只存储2个副本, 这时冗余度是200%, 也有了1倍的存储空间浪费。
服务器1 服务器2 服务器3 Data1 Data1 Data1 Data2 Data2 Data2 Data3 Data3 Data3 纠删码基本原理 K+1的冗余实现 有三个自然数，做到记录四个数字实现任意一个数字丢失都可以被找回。
解： 记录这三个数字之和即可实现这个需求
$$ y_{1} = x_{1} + x_{2} + x_{3} $$
如果 $$ x_{2} $$
丢失后只需要
$$ x_{2} = y_{1} - x_{1} - x_{3} $$
即可求出对应的值，如果是y丢失了，只需要重新计算对应的和即可。
在这个方案下一共存储了4份数据，其中实际有效的数据是3份， 冗余133%， 基本实现了和2副本类似的可靠性。这个方式和日常使用的raid5基本一致，raid5同样是计算一份校验和的数据进行存储，并且允许一块坏掉后进行恢复。
存储策略 冗余 可靠性 两副本 200% 允许丢一块 3+1冗余 133% 允许丢一块 K+2的冗余实现 在上面多一个数字存储的情况下，再加一个数字的存储来实现，丢失任意两个数字可以实现找回。
解： 在k+1的实现中，是给所有的数据块和校验块构建了一个求和的关系来进行关联。
$$ y_{1} = x_{1} + x_{2} + x_{3} $$
现在想要增加可以丢失的数据块，不能单纯的进行存两次和来实现。
$$ y_{1} = x_{1} + x_{2} + x_{3} $$
$$ y_{2} = x_{1} + x_{2} + x_{3} $$
$$ y_{2} = y_{1} $$
* 存储 $$ y_{1} ,y_{2}, x_{1},x_{2},x_{3} $$
5个数字 * 当需要恢复数据时，假设
$$ x_{1}, x_{2} $$
丢失了，那么下面这个线性方程是有无数个解的，我们无法从中计算出 丢失的两个数字是多少。这两个方程是一样的，基本没有什么求解的意义。
$$ x_{1} + x_{2} = y_{1} - x_{3} $$
$$ x_{1} + x_{2} = y_{2} - x_{3} $$
我们用一个简单的方案来让两个方程不一样，这样才会有解。在计算
$$ y_{2} $$
时我们给每个数据增加一个不同的系数。
* 计算 $$ y_{1} $$
时针对每个数字都乘以1 * 计算
$$ y_{2} $$
时针对每个数字都乘以
$$ 2^{0} \quad 2^{1} \quad 2^{2} \quad2^{3} $$
（系数规范可以自己定义）
$$ y_{1} = x_{1} + x_{2} + x_{3} $$
$$ y_{2} = 1 * x_{1} + 2 * x_{2} + 4 * x_{3} $$
存储过程仍旧是存储
$$ y_{1},
y_{2},
x_{1},
x_{2},
x_{3} $$
5个数字，当出现两个数据丢失时可以构建，下面的二元一次方程组。求解这个方程组，即可获取丢失的两个数据
$$ x_{1} , x_{2} $$
。以上这种加系数计算校验块的方式, 就是 RAID-6 的基本工作方式——为k个数据块之外再多存储2个校验数据, 当整个系统丢失2块数据时, 都可以找回。
$$ x_{1} + x_{2} = y_{1} - x_{3} $$
$$ x_{1} + 2x_{2} = y_{2} - 4x_{3} $$
有理数下k+2的EC的算法大概就出来了, 我们可以实现k+2的冗余策略, 通过166%的冗余, 实现差不多和三副本300%一样的可靠性。
K+M的冗余校验 如果需要增加更多的冗余来让纠删码实现类似4副本的可靠性 K+3， 那么只需要再增加一个校验块
$$ y_{3} $$
来实现。当我们计算新的
$$ y_{3} $$
时需要提供一个新的系数
$$ 3^{0} \quad 3^{1} \quad 3^{2} \quad 3^{3} $$
来保证当出现数据丢失时可以进行找回。
$$ y_{1} = x_{1} + x_{2} + x_{3} $$
$$ y_{2} = 1 * x_{1} + 2 * x_{2} + 4 * x_{3} $$
$$ y_{3} = 1 * x_{1} + 3 * x_{2} + 9 * x_{3} $$
如何进一步实现冗余，那么进一步增加新的系数，就可以实现恢复。
$$ y_{M} = z_{1} * x_{1} + z_{2} * x_{2} + z_{3} * x_{3} + &amp;hellip; + z_{m} * x_{M} $$
默认minio的ec比是数据盘和校验盘1：1， 冗余度是（实际数据+冗余数据）/实际数据， 按照石墨集群默认是6个节点3：3来看数据丢失的可能性大约是
$$ 2 * 10^{-15} $$</content></entry><entry><title>Hello World</title><url>/posts/hello-world/</url><categories/><tags><tag>hugo</tag></tags><content type="html">hello world this is my first notes.</content></entry></search>