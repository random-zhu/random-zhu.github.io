<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>GitFlow开发流程</title><url>/posts/gitflow%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url><categories/><tags><tag>git</tag><tag>开发</tag></tags><content type="html"><![CDATA[git Flow工作流 （截取自极客时间)
git flow工作流是一个成熟的方案，也是非开源项目中常用到的工作流。 定义了一个围绕项目发布的严格分支模型，通过为代码开发，发布和维护分配独立的分支来让项目迭代流程更加顺畅，比较适合大型项目或者迭代快速的项目。
git flow的5种分支 git flow中定义了5中分支，分别是master，develop，feature，release和hotfix。其中master和develop是常驻分支， 其他为非常驻分支，不同的研发阶段会用到不同的分支。
分支名 描述 master 该分支上的最新代码永远是发布状态，不能直接在该分支上进行开发。master分支每合并一个 hotfix/release分支，都会打一个版本标签 develop 该分支上的代码是开发中的最新代码，该分支只做合并操作，不能直接在该分支上进行开发 feature 在研发阶段用来做功能开发。 一个新的功能会基于develop分之创建一个新的feature分支，分支名建议命名为 feature/xxx-xx。功能开发完成后，
会合并到develop分支并删除，这里有一点需要注意，feature在合并前，最好是先pull下develop分支，检查下是否有冲突，如果存在冲突先解决
冲突之后再申请合并。 release 在发布阶段用作版本发布的预发布分支，基于develop分之创建，分支名建议命名为： release/xxx 例如 v1.0.0版本的功能全部开发完成后，会提
交到develop分支，然后基于develop分支创建release/1.0.0 分支并提交测试，测试中遇到分支来release进行修改，最终通过测试后，将release分支
合并到master和develop分支。并在master分支上打上v1.0.0的版本标签，最后删除release/1.0.0分支。 hotfix 在维护阶段用来做紧急bugfix的修复分支，在master上创建，修复完成后合并到master。分支名建议命名为hotfix/xxx-xxx。 例如 当线上某个版本出现
bug后，从master检出对应版本代码，创建hotfix分支，并在hotfix分支上修复问题。问题修复后，将hotfix分之合并到master和develop分支，并在master
分支上打上修复后的版本标签，最后删除hotfix分支。 git flow开发流程 用一个例子来演示 git flow工作流程。 场景如下
当前版本： 0.9.0 需要开发一个新的功能，使程序执行时向标准输出打印“hello world&quot; 字符串 在开发阶段有线上bug需要进行修复 具体流程如下：
创建一个常驻的分支：develop。
$ git checkout -b develop master 基于 develop 分支，新建一个功能分支：feature/print-hello-world。
$ git checkout -b feature/print-hello-world develop feature/print-hello-world 分支中，在 main.go 文件中添加一行代码fmt.Println(&ldquo;Hello&rdquo;)
紧急修复 Bug。我们正处在新功能的开发中（只完成了 fmt.Println(&ldquo;Hello&rdquo;)而非 fmt.Println(&ldquo;Hello World&rdquo;)）突然线上代码发现了一个 Bug，我们要立即停止手上的工作，修复线上的 Bug，步骤如下。
$ git stash # 1. 开发工作只完成了一半，还不想提交，可以临时保存修改至堆栈区 $ git checkout -b hotfix/print-error master # 2. 从 master 建立 hotfix 分支 $ vi main.go # 3. 修复 bug，callmainfunction -&gt; call main function $ git commit -a -m &#39;fix print message error bug&#39; # 4. 提交修复 $ git checkout develop # 5. 切换到 develop 分支 $ git merge --no-ff hotfix/print-error # 6. 把 hotfix 分支合并到 develop 分支 $ git checkout master # 7. 切换到 master 分支 $ git merge --no-ff hotfix/print-error # 8. 把 hotfix 分支合并到 master $ git tag -a v0.9.1 -m &#34;fix log bug&#34; # 9. master 分支打 tag $ go build -v . # 10. 编译代码，并将编译好的二进制更新到生产环境 $ git branch -d hotfix/print-error # 11. 修复好后，删除 hotfix/xxx 分支 $ git checkout feature/print-hello-world # 12. 切换到开发分支下 $ git merge --no-ff develop # 13. 因为 develop 有更新，这里最好同步更新下 $ git stash pop # 14. 恢复到修复前的工作状态 继续开发。 在 main.go 中加入 fmt.Println(&ldquo;Hello World&rdquo;)。
提交代码到 feature/print-hello-world 分支。
$ git push origin feature/print-hello-world 在 feature/print-hello-world 分支上做 code review。
$ git push origin feature/print-hello-world 然后，我们在 GitHub 上，基于 feature/print-hello-world 创建 pull request。 创建完 pull request 之后，我们就可以指定 Reviewers 进行 code review，如下图所示。
code review 通过后，由代码仓库 matainer 将功能分支合并到 develop 分支。
$ git checkout develop $ git merge --no-ff feature/print-hello-world 基于 develop 分支，创建 release 分支，测试代码。
$ git checkout -b release/1.0.0 develop $ go build -v . # 构建后，部署二进制文件，并测试 测试失败，因为我们要求打印“hello world”，但打印的是“Hello World”，修复的时候，我们直接在 release/1.0.0 分支修改代码，修改完成后，提交并编译部署。
$ git commit -a -m &#34;fix bug&#34; $ go build -v . 测试通过后，将功能分支合并到 master 分支和 develop 分支。
$ git checkout develop $ git merge --no-ff release/1.0.0 $ git checkout master $ git merge --no-ff release/1.0.0 $ git tag -a v1.0.0 -m &#34;add print hello world&#34; # master 分支打 tag 删除 feature/print-hello-world 分支，也可以选择性删除 release/1.0.0 分支。
$ git branch -d feature/print-hello-world 优缺点 缺点，它有一定的上手难度。 优点：Git Flow 工作流的每个分支分工明确，这可以最大程度减少它们之间的相互影响。因为可以创建多个分支，所以也可以并行开发多个功能。另外，和功能分支工作流一样，它也可以添加 code review，保障代码质量。 ]]></content></entry><entry><title>Rust基本数据类型</title><url>/posts/rust%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url><categories/><tags><tag>rust</tag><tag>编程语言</tag></tags><content type="html"><![CDATA[类型系统 什么是类型 减少开发者心智负担 安全 容易优化 常见的类型分类 静态类型，在编译阶段对类型进行检查 动态类型， 在运行期间对类型进行检查 强类型，不允许隐式类型转换 (pyhon是动态强类型) 弱类型，允许进行隐式类型转换 c语言由于允许隐式类型转换因此是静态弱类型
int main() { long a = 10; return a; } rust是静态强类型
变量和可变性 创建和使用变量 在rust中可以使用let关键字进行变量赋值
fn main() { let x=5; println!(&#34;the value of x is {}&#34;, x); } 在rust中变量默认不可变
fn main() { let x=5; println!(&#34;the value of x is {}&#34;, x); x = 6; println!(&#34;the value of x is {}&#34;, x); } 在创建变量前增加mut使得变量可变
fn main() { let mut x=5; println!(&#34;the value of x is {}&#34;, x); x = 6; println!(&#34;the value of x is {}&#34;, x); } 常量和不可变变量
常量使用const关键字 可以在任何位置定义
const A_CONST: i32= 42; fn main() { let mut x=5; println!(&#34;the value of x is {}&#34;, x); x = 6; println!(&#34;the value of x is {}&#34;, x); println!(&#34;the value of x is {}&#34;, A_CONST); } 常量在编译期间进行求值，不可变变量是在运行期期间进行求值
const A_CONST: i32= 42 + 2 - 1 //常量表达式 在编译期求值 const A_CONST: i32= get_number(); //不能将一个函数的返回值作为常量 fn get_number() -&gt; i32 { 42 } fn main() { let r = get_number(); // 函数的返回值可以作为一个不可变变量的值 println!(&#34;the value of x is {}&#34;, r); } 变量的隐藏 shadowing
可以声明与前一个变量同名的新变量, 新变量会隐藏前一个变量
fn main() { let x = 5; let x= x+1; let x = x * 2; println!(&#34;{}&#34;, x); } // 推荐使用上面的隐藏的写法 fn main() { let mut x = 5; x= x+1; x = x * 2; println!(&#34;{}&#34;, x); } 基础数据类型 由于rust是一门静态编程语言
整数 rust有12种不同的整数类型
长度 有符号 无符号 8 bit i8 u8 16 bit i16 u16 32 bit i32 u32 64 bit i64 u64 128 bit i128 u128 arch isize usize 对于未明确标注类型的整数，rust默认使用i32
isize和usize根据系统的不同而有不同的长度
如果只是一个正的数字推荐使用无符号，否则使用有符号
浮点数 rust有两种浮点数类型为f32和f64, 后者的精度更加高
对于未明确标注类型的小数， rust默认使用f64
fn main() { let x = 2.0; // f64 let y: f32 = 3.0; // f32 } 布尔值 与大多数其他编程语言一样，rust的布尔值有两个可能的值， true和false, 大小均为一个字节
fn main() { let t = true; let f: bool = false; } 字符 rust支持单个字符，字符使用单引号包装
fn main() { let c = &#39;z&#39;; let z = &#39;ℤ&#39;; let heart_eyed_cat = &#39;😻&#39;; println!(&#34;{} {} {}&#34;, c, z, heart_eyed_cat) } 例题 编写一个函数，它接受两个u32类型的参数，并且返回其平均数，ps 考虑其整数溢出的问题 下面是用例
fn main() { assert_eq!(avg(4294967295, 4294967295), 4294967295); assert_eq!(avg(0, 0), 0); assert_eq!(avg(10, 20), 15); assert_eq!(avg(4294967295, 1), 2147483648); println!(&#34;passed&#34;) } fn avg(a: u32, b: u32) -&gt; u32{ (a &amp; b) + ((a ^ b) &gt;&gt; 1 ) } 整数溢出 在电脑领域里所发生的溢出条件是, 运行单项数值计算时, 当计算产生出来的结果是非常大的, 大于寄存器或存储器所能存储或表示的能力限制就会发生溢出.
在不同的编程语言中, 对待溢出通常有以下几种不同的做法:
崩溃: 当溢出被侦测到时, 程序立即退出运行 忽略: 这是最普遍的作法, 忽略任何算数溢出 对于溢出的处理方法, Rust 在 debug 与 release 模式下是不同的. 在 debug 模式下编译时, Rust 会检查整数溢出, 如果发生这种行为, 会导致程序在运行时终止并报出运行时错误. 而如果在 release 模式下编译时, Rust 不会对整数溢出进行检查.
要显式处理溢出, 可以使用标准库提供的一些 .overflowing_* 方法:
fn main() { let a: u32 = 4294967295; let b: u32 = 1; let (r, is_overflow) = a.overflowing_add(b); println!(&#34;r={} is_overflow={}&#34;, r, is_overflow); } 元组 元组是将多个具有各种类型的值组合成一个复合类型的通用方法，元组有固定长度，一旦声明，他们的大小就不能增长或者收缩。
通过在括号内写一个逗号分隔的值列表来创建一个元组，元组中的每个位置都有一个类型，元组中不同值的类型不必相同.
fn main() { let a: i32 = 10; let b: char = &#39;A&#39;; // 创建一个元组 let mytuple: (i32, char) = (a, b); // 从元组中读取一个值 println!(&#34;.0={:?}&#34;, mytuple.0); println!(&#34;.1={:?}&#34;, mytuple.1); // 解封装 let (c, d) = mytuple; println!(&#34;c={} d={}&#34;, c, d); } 数组 rust中另一种具有多个数据集合的方法是数组，与元组不同，数据的每一个元素的类型都必须相同，rust中的数组不同于其他的语言，rust的数据足有固定的长度。
数组的下标以0开始，同时rust存在越界检查。
fn main() { // 创建数组, [i32; 3] 是数组的类型提示, 表示元素的类型是 i32, 共有 3 个元素 let myarray: [i32; 3] = [1, 2, 3]; // 根据索引获取一个值, 数组下标从 0 开始 println!(&#34;{:?}&#34;, myarray[1]); //:?也可以不写 // 索引不能越界 println!(&#34;{:?}&#34;, myarray[3]); // 如果数组的每个元素都有相同的值, 我们还可以简化数组的初始化 let myarray: [i32; 3] = [0; 3]; println!(&#34;{:?}&#34;, myarray[1]); } 切片类型 切片类型是对一个数组(包括固定大小数组和动态数组)的引用片段, 有利于安全有效地访问数组的一部分, 而不需要拷贝数组或数组中的内容. 切片在编译的时候其长度是未知的, 在底层实现上, 一个切片保存着两个 uszie 成员, 第一个 usize 成员指向切片起始位置的指针, 第二个 usize 成员表示切片长度.
fn main() { let arr: [i32; 5] = [1, 2, 3, 4, 5]; let slice = &amp;arr[0..3]; // 取前 3 个元素 println!(&#34;slice[0]={}, len={}&#34;, slice[0], slice.len()); } 结构体 结构体是多种不同数据类型的组合. 它与元组类似, 但区别在于我们可以为每个成员命名. 可以使用 struct 关键字创建三种类型的结构:
元组结构 经典的 C 结构 无字段的单元结构 结构体使用驼峰命名.
// 元组结构 struct Pair(i32, f32); // 经典的 C 结构 struct Person { name: String, age: u8, } // 无字段的单元结构, 在泛型中较为常用 struct Unit; fn main() { // 结构体的实例化 let pair = Pair(10, 4.2); let person = Persion { name: String::from(&#34;jack&#34;), age: 21, }; let unit = Unit; // 从结构体中获取成员 println!(&#34;{}&#34;, pari.0); println!(&#34;{}&#34;, persion.name); } 枚举 enum关键字可以创建枚举类型，枚举类型包含了取值的全部可能情况，在rust中有多种不同形式的枚举写法。
无参数的枚举 enum Planet { Mars, Earth, } 上面的代码定义了枚举Planet包含了两个值Mars和Earth.
带枚举值的枚举 enum Color { Red = OxffOOOO, Green = OxOOffOO, Blue = OxOOOOff, } 带参数的枚举 支持带类型参数的枚举
enum IpAddr { IPv4(u8, u8, u8, u8), IPv6(u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8), } 模式匹配 枚举通常与 match 模式匹配一起使用.
enum IpAddr { IPv4(u8, u8, u8, u8), IPv6(u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8), } fn main() { let localhost: IpAddr = IpAddr::IPv4(127, 0, 0, 1); match localhost { IpAddr::IPv4(a, b, c, d) =&gt; { println!(&#34;{} {} {} {}&#34;, a, b, c, d); } _ =&gt; {} // 任何非 IPv4 类型走这条分支 } } println println! 用于将数据打印到标准输出, 且在数据末尾自动带上换行符. 在所有平台上, 换行符都是换行符(没有额外的回车符).
使用 println! 用于程序的正常输出, 使用 eprintln! 打印错误或者进度条. 前者数据被写入 stdout, 后者则是 stderr. println! 宏常用的格式化语法如下所示:
fn main() { // `{}` 会被变量内容替换, 这是最常见的一种用法 println!(&#34;{}&#34;, 42); // 可以使用额外的位置参数. println!(&#34;{0}{1}{0}&#34;, 4, 2); // 使用命名参数. println!(&#34;name={name} age={age}&#34;, name=&#34;jack&#34;, age=6); // 可以在 `:` 后面指定特殊的格式. println!(&#34;{} of {:b} people know binary, the other half don&#39;t&#34;, 1, 2); // 可以按指定宽度来右对齐文本. println!(&#34;{number:&gt;width$}&#34;, number=1, width=6); // 在数字左边补 0.下面语句输出 &#34;000001&#34;. println!(&#34;{number:&gt;0width$}&#34;, number=1, width=6); // println! 会检查使用到的参数数量是否正确. println!(&#34;My name is {0}, {1} {0}&#34;, &#34;Bond&#34;); // 编译将会报错, 请补上漏掉的参数：&#34;James&#34; } 类型转换 Rust 是一门强类型语言, 因此不支持隐式类型转换. Rust 为了实现类型之间的转换提供了几种不同的方法.
as语法 as 语法是 Rust 最基础的一种类型转换方法, 它通常用于整数, 浮点数和字符数据之间的类型转换.
fn main() { let a: i8 = -10; let b = a as u8; println!(&#34;a={} b={}&#34;, a, b); } 数值转换的语义是:
两个相同大小的整型之间(例如: i32-&gt;u32)的转换是一个 no-op 从一个大的整型转换为一个小的整型(例如: u32-&gt;u8)会截断 从一个小的整型转换为一个大的整型(例如: u8-&gt;u32)会 如果源类型是无符号的会补零(zero-extend) 如果源类型是有符号的会符号(sign-extend) 从一个浮点转换为一个整型会向 0 舍入 从一个整型转换为一个浮点会产生整型的浮点表示，如有必要会舍入(未指定舍入策略) 从 f32 转换为 f64 是完美无缺的 从 f64 转换为 f32 会产生最接近的可能值(未指定舍入策略) transmute as 只允许安全的转换, 例如会拒绝例如尝试将 4 个字节转换为一个 u32:
let a = [0u8, 0u8, 0u8, 0u8]; let b = a as u32; // Four u8s makes a u32. 但是我们知道 u32 在内存中表示为 4 个连续的 u8, 因此我们可以使用一种危险的方法: 告诉编译器直接以另一种数据类型对待内存中的数据. 编译器会无条件信任你. 但是, 除非你知道自己在干什么, 不然并不推荐使用 transmute. 要使用 transmute, 需要将代码写入 unsafe 块中.
fn main() { unsafe { let a = [0u8, 1u8, 0u8, 0u8]; let b = mem::transmute::&lt;[u8; 4], u32&gt;(a); println!(&#34;{}&#34;, b); // 256 // Or, more concisely: let c: u32 = mem::transmute(a); println!(&#34;{}&#34;, c); // 256 } } ]]></content></entry><entry><title>数组链表栈和队列</title><url>/posts/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url><categories/><tags/><content type="html">知识点 数组 连续的存储空间 一次性定位（通过index） 快速定位查找，插入删除 较差 链表 离散的存储空间 通过next节点定位下一个list node 删除， 插入相对简单； 查找相对数组复杂（除了头节点外) 栈 stack 先进后出的数据结构（类似杯子只有一个出口) 队列 先进先出的数据结构 （类似排队) 练习题 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。
示例 1：
输入：digits = [1,2,3] 输出：[1,2,4] 解释：输入数组表示数字 123。 示例 2：
输入：digits = [4,3,2,1] 输出：[4,3,2,2] 解释：输入数组表示数字 4321。 示例 3：
输入：digits = [0] 输出：[1] 分析：
数组假定为数字 1+1 = 2 9+1 = 10 99+1 = 100 从最后一个数字开始遍历 最后一位加一 剩余的加上进位 需要一个变量存储进位</content></entry><entry><title>Nginx Upstream Oss</title><url>/posts/nginx-upstream-oss/</url><categories/><tags><tag>nginx</tag><tag>oss</tag></tags><content type="html">需求 私有部署的前端资源均由前端nodejs服务直接返回，同时也没有相关缓存的配置，导致请求会占用比较多的服务器带宽资源，计划将资源全部切换到对象存储中使用cdn回源的方式来进行访问。 这样做既可以减少带宽的使用，同时也可以借助cdn更好的用户接入点来优化访问速度。
实施 切换oss 和业务沟通后支持nodejs服务直接将资源相对路径拼接阿里oss地址， 阿里云在当地尚未上线cdn所以直接使用oss 公共读平替，上线到测试环境观察一段时间后。反馈服务器带宽资源有降低， 但是用户的的访问效果依旧不太好， 还是有反馈很慢的情况。 检查后发现阿里云oss默认使用http 1.1进行返回, 同时还有很多未使用缓存的情况，与阿里云售后确认oss不能直接使用http2, 除非绑定对应cdn。
在确认cdn上线时间未知后，计划在oss上将对应的文件均配置为一年的缓存策略。
ossutil set-meta oss://public/ Cache-Control:max-age=31536000 -r --update 跨域的坑 既然切换了对象存储使用公开读的方式，那么跨域配置也就是必要的了，在对应oss上配置了 AllowedOrigin: * AllowedMethod: GET HEAD 的对应规则，配置好后一段时间风平浪静~~~
大概过了几天有用户和测试反馈说有页面无法打开，chrome调试窗口看发现有资源出现了跨域的告警。前端同事远程后发现静态资源的相应头少了 access-control-allow-origin: * 这个header， oss也不支持全部请求都返回这个header除非使用cdn。重新沟通后计划使用nginx做一层代理来进行header的添加和修改。
proxy_set_header Origin &amp;#39;https://xxx.com&amp;#39;; #对应来源域名 proxy_hide_header access-control-allow-methods; proxy_hide_header access-control-expose-headers; proxy_pass: oss地址 header 里面 access-control 相关的 header 只能带 access-control-allow-origin: * ，带上其他的就会影响缓存响应时的 header ，一样会导致 cors error，因为读取缓存的时候 header 里没有带 access-control-allow-origin: *</content></entry><entry><title>Minio纠删码</title><url>/posts/minio%E7%BA%A0%E5%88%A0%E7%A0%81/</url><categories/><tags><tag>minio</tag><tag>对象存储</tag></tags><content type="html">数据可靠性的方案 冗余 多副本 多副本一般就是一份数据存储多份，并且每份数据都保存在不用的服务器或者跨机房，地域。 通常情况下副本一般是3个， 大约是11个9的可靠性。 ps:
我有3个文件，每个文件都大约是1g。 按照三个副本的方式复制3份，然后放在不同的服务器上进行保存。这种3副本的策略下, 总的存储冗余度是 300% 空间浪费是200%。
当然有些时候为了降低成本, 只存储2个副本, 这时冗余度是200%, 也有了1倍的存储空间浪费。
服务器1 服务器2 服务器3 Data1 Data1 Data1 Data2 Data2 Data2 Data3 Data3 Data3 纠删码基本原理 K+1的冗余实现 有三个自然数，做到记录四个数字实现任意一个数字丢失都可以被找回。
解： 记录这三个数字之和即可实现这个需求
$$ y_{1} = x_{1} + x_{2} + x_{3} $$
如果 $$ x_{2} $$
丢失后只需要
$$ x_{2} = y_{1} - x_{1} - x_{3} $$
即可求出对应的值，如果是y丢失了，只需要重新计算对应的和即可。
在这个方案下一共存储了4份数据，其中实际有效的数据是3份， 冗余133%， 基本实现了和2副本类似的可靠性。这个方式和日常使用的raid5基本一致，raid5同样是计算一份校验和的数据进行存储，并且允许一块坏掉后进行恢复。
存储策略 冗余 可靠性 两副本 200% 允许丢一块 3+1冗余 133% 允许丢一块 K+2的冗余实现 在上面多一个数字存储的情况下，再加一个数字的存储来实现，丢失任意两个数字可以实现找回。
解： 在k+1的实现中，是给所有的数据块和校验块构建了一个求和的关系来进行关联。
$$ y_{1} = x_{1} + x_{2} + x_{3} $$
现在想要增加可以丢失的数据块，不能单纯的进行存两次和来实现。
$$ y_{1} = x_{1} + x_{2} + x_{3} $$
$$ y_{2} = x_{1} + x_{2} + x_{3} $$
$$ y_{2} = y_{1} $$
* 存储 $$ y_{1} ,y_{2}, x_{1},x_{2},x_{3} $$
5个数字 * 当需要恢复数据时，假设
$$ x_{1}, x_{2} $$
丢失了，那么下面这个线性方程是有无数个解的，我们无法从中计算出 丢失的两个数字是多少。这两个方程是一样的，基本没有什么求解的意义。
$$ x_{1} + x_{2} = y_{1} - x_{3} $$
$$ x_{1} + x_{2} = y_{2} - x_{3} $$
我们用一个简单的方案来让两个方程不一样，这样才会有解。在计算
$$ y_{2} $$
时我们给每个数据增加一个不同的系数。
* 计算 $$ y_{1} $$
时针对每个数字都乘以1 * 计算
$$ y_{2} $$
时针对每个数字都乘以
$$ 2^{0} \quad 2^{1} \quad 2^{2} \quad2^{3} $$
（系数规范可以自己定义）
$$ y_{1} = x_{1} + x_{2} + x_{3} $$
$$ y_{2} = 1 * x_{1} + 2 * x_{2} + 4 * x_{3} $$
存储过程仍旧是存储
$$ y_{1},
y_{2},
x_{1},
x_{2},
x_{3} $$
5个数字，当出现两个数据丢失时可以构建，下面的二元一次方程组。求解这个方程组，即可获取丢失的两个数据
$$ x_{1} , x_{2} $$
。以上这种加系数计算校验块的方式, 就是 RAID-6 的基本工作方式——为k个数据块之外再多存储2个校验数据, 当整个系统丢失2块数据时, 都可以找回。
$$ x_{1} + x_{2} = y_{1} - x_{3} $$
$$ x_{1} + 2x_{2} = y_{2} - 4x_{3} $$
有理数下k+2的EC的算法大概就出来了, 我们可以实现k+2的冗余策略, 通过166%的冗余, 实现差不多和三副本300%一样的可靠性。
K+M的冗余校验 如果需要增加更多的冗余来让纠删码实现类似4副本的可靠性 K+3， 那么只需要再增加一个校验块
$$ y_{3} $$
来实现。当我们计算新的
$$ y_{3} $$
时需要提供一个新的系数
$$ 3^{0} \quad 3^{1} \quad 3^{2} \quad 3^{3} $$
来保证当出现数据丢失时可以进行找回。
$$ y_{1} = x_{1} + x_{2} + x_{3} $$
$$ y_{2} = 1 * x_{1} + 2 * x_{2} + 4 * x_{3} $$
$$ y_{3} = 1 * x_{1} + 3 * x_{2} + 9 * x_{3} $$
如何进一步实现冗余，那么进一步增加新的系数，就可以实现恢复。
$$ y_{M} = z_{1} * x_{1} + z_{2} * x_{2} + z_{3} * x_{3} + &amp;hellip; + z_{m} * x_{M} $$
默认minio的ec比是数据盘和校验盘1：1， 冗余度是（实际数据+冗余数据）/实际数据， 按照石墨集群默认是6个节点3：3来看数据丢失的可能性大约是
$$ 2 * 10^{-15} $$</content></entry><entry><title>Hello World</title><url>/posts/hello-world/</url><categories/><tags><tag>hugo</tag></tags><content type="html">hello world this is my first notes.</content></entry></search>