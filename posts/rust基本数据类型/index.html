<!doctype html><html lang=zh-cn data-theme=dark><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.110.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Rust基本数据类型"><meta itemprop=description content="保持简单的生活状态。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://avatars.githubusercontent.com/u/24290710?s=400&u=23bacf97f91c4c2b61df5dbdb59745bb5199ac9a&v=4"><meta itemprop=keywords content="rust,编程语言"><meta property="og:type" content="article"><meta property="og:title" content="Rust基本数据类型"><meta property="og:description" content="保持简单的生活状态。"><meta property="og:image" content="https://avatars.githubusercontent.com/u/24290710?s=400&u=23bacf97f91c4c2b61df5dbdb59745bb5199ac9a&v=4"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://random-zhu.github.com/posts/rust%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"><meta property="og:site_name" content="random-notes"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="random-zhu"><meta property="article:published_time" content="2023-02-28 22:37:30 +0800 CST"><meta property="article:modified_time" content="2023-02-28 22:37:30 +0800 CST"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.4abb316f60da8ca115f3a982367f32d99de3b3717a874139f3e0c382ac5e6c33.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"math":{"js":{"file":"es5/tex-mml-chtml.js","name":"mathjax","version":"3.2.0"},"render":"mathjax"},"path":"rust%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B","permalink":"https://random-zhu.github.com/posts/rust%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","title":"Rust基本数据类型"}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>Rust基本数据类型 - random-notes</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>random-notes</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>工作与日常</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-archives"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>5</span></a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#什么是类型>什么是类型</a></li><li><a href=#常见的类型分类>常见的类型分类</a></li><li><a href=#变量和可变性>变量和可变性</a><ul><li><a href=#创建和使用变量>创建和使用变量</a></li></ul></li><li><a href=#基础数据类型>基础数据类型</a><ul><li><a href=#整数>整数</a></li><li><a href=#浮点数>浮点数</a></li><li><a href=#布尔值>布尔值</a><ul><li><a href=#字符>字符</a></li></ul></li><li><a href=#例题>例题</a></li><li><a href=#整数溢出>整数溢出</a></li><li><a href=#元组>元组</a></li><li><a href=#数组>数组</a></li><li><a href=#切片类型>切片类型</a></li><li><a href=#结构体>结构体</a></li><li><a href=#枚举>枚举</a><ul><li><a href=#无参数的枚举>无参数的枚举</a></li><li><a href=#带枚举值的枚举>带枚举值的枚举</a></li><li><a href=#带参数的枚举>带参数的枚举</a></li><li><a href=#模式匹配>模式匹配</a></li></ul></li><li><a href=#println>println</a><ul><li><a href=#类型转换>类型转换</a></li></ul></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=random-zhu src=/imgs/img-lazy-loading.gif data-src="https://avatars.githubusercontent.com/u/24290710?s=400&u=23bacf97f91c4c2b61df5dbdb59745bb5199ac9a&v=4"><p class=site-author-name itemprop=name>random-zhu</p><div class=site-description itemprop=description>保持简单的生活状态。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>5</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>0</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>7</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://random-zhu.github.com/posts/rust%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="https://avatars.githubusercontent.com/u/24290710?s=400&u=23bacf97f91c4c2b61df5dbdb59745bb5199ac9a&v=4"><meta itemprop=name content="random-zhu"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="random-zhu"><meta itemprop=description content="保持简单的生活状态。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Rust基本数据类型"><meta itemprop=description content="类型系统 什么是类型 减少开发者心智负担 安全 容易优化 常见的类型分类 静态类型，在编译阶段对类型进行检查 动态类型， 在运行期间对类型进行检查 强类型，不"></span><header class=post-header><h1 class=post-title itemprop="name headline">Rust基本数据类型</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>发表于：</span>
<time title="发表于：2023-02-28 22:37:30 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-02-28 22:37:30 +0800 CST">2023-02-28</time></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span><span>3076</span></span>
<span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>阅读：&ap;</span>
<span>7分钟</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=busuanzi_value_page_pv data-path=/posts/rust%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h1 id=类型系统>类型系统</h1><h2 id=什么是类型>什么是类型</h2><ul><li>减少开发者心智负担</li><li>安全</li><li>容易优化</li></ul><h2 id=常见的类型分类>常见的类型分类</h2><ul><li>静态类型，在编译阶段对类型进行检查</li><li>动态类型， 在运行期间对类型进行检查</li><li>强类型，不允许隐式类型转换 (pyhon是动态强类型)</li><li>弱类型，允许进行隐式类型转换</li></ul><p>c语言由于允许隐式类型转换因此是静态弱类型</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>long</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> a;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>rust是静态强类型</p><h2 id=变量和可变性>变量和可变性</h2><h3 id=创建和使用变量>创建和使用变量</h3><p>在rust中可以使用let关键字进行变量赋值</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;the value of x is {}&#34;</span>, x);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在rust中变量默认不可变</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;the value of x is {}&#34;</span>, x);
</span></span><span style=display:flex><span>    x <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;the value of x is {}&#34;</span>, x);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在创建变量前增加mut使得变量可变</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> x<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;the value of x is {}&#34;</span>, x);
</span></span><span style=display:flex><span>    x <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;the value of x is {}&#34;</span>, x);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>常量和不可变变量</p><p>常量使用const关键字 可以在任何位置定义</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> A_CONST: <span style=color:#66d9ef>i32</span><span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> x<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;the value of x is {}&#34;</span>, x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    x <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;the value of x is {}&#34;</span>, x);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;the value of x is {}&#34;</span>, A_CONST);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>常量在编译期间进行求值，不可变变量是在运行期期间进行求值</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>const</span> A_CONST: <span style=color:#66d9ef>i32</span><span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e>//常量表达式 在编译期求值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> A_CONST: <span style=color:#66d9ef>i32</span><span style=color:#f92672>=</span> get_number(); <span style=color:#75715e>//不能将一个函数的返回值作为常量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_number</span>() -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>42</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> r <span style=color:#f92672>=</span> get_number();  <span style=color:#75715e>// 函数的返回值可以作为一个不可变变量的值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;the value of x is {}&#34;</span>, r); 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>变量的隐藏 shadowing</p><p>可以声明与前一个变量同名的新变量, 新变量会隐藏前一个变量</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x<span style=color:#f92672>=</span> x<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> x <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;{}&#34;</span>, x);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 推荐使用上面的隐藏的写法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {   
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>     x<span style=color:#f92672>=</span> x<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>     x <span style=color:#f92672>=</span> x <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;{}&#34;</span>, x);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=基础数据类型>基础数据类型</h2><p>由于rust是一门静态编程语言</p><h3 id=整数>整数</h3><p>rust有12种不同的整数类型</p><table><thead><tr><th>长度</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>8 bit</td><td>i8</td><td>u8</td></tr><tr><td>16 bit</td><td>i16</td><td>u16</td></tr><tr><td>32 bit</td><td>i32</td><td>u32</td></tr><tr><td>64 bit</td><td>i64</td><td>u64</td></tr><tr><td>128 bit</td><td>i128</td><td>u128</td></tr><tr><td>arch</td><td>isize</td><td>usize</td></tr></tbody></table><ul><li><p>对于未明确标注类型的整数，rust默认使用i32</p></li><li><p>isize和usize根据系统的不同而有不同的长度</p><p>如果只是一个正的数字推荐使用无符号，否则使用有符号</p></li></ul><h3 id=浮点数>浮点数</h3><p>rust有两种浮点数类型为f32和f64, 后者的精度更加高</p><p>对于未明确标注类型的小数， rust默认使用f64</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>2.0</span>;  <span style=color:#75715e>// f64
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> y: <span style=color:#66d9ef>f32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.0</span>;  <span style=color:#75715e>// f32
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=布尔值>布尔值</h3><p>与大多数其他编程语言一样，rust的布尔值有两个可能的值， true和false, 大小均为一个字节</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> t <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> f: <span style=color:#66d9ef>bool</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=字符>字符</h4><p>rust支持单个字符，字符使用单引号包装</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;z&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> z <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;ℤ&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> heart_eyed_cat <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;😻&#39;</span>;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;{} {} {}&#34;</span>, c, z, heart_eyed_cat)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=例题>例题</h3><p>编写一个函数，它接受两个u32类型的参数，并且返回其平均数，ps 考虑其整数溢出的问题 下面是用例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    assert_eq!(avg(<span style=color:#ae81ff>4294967295</span>, <span style=color:#ae81ff>4294967295</span>), <span style=color:#ae81ff>4294967295</span>);
</span></span><span style=display:flex><span>    assert_eq!(avg(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    assert_eq!(avg(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>20</span>), <span style=color:#ae81ff>15</span>);
</span></span><span style=display:flex><span>    assert_eq!(avg(<span style=color:#ae81ff>4294967295</span>, <span style=color:#ae81ff>1</span>), <span style=color:#ae81ff>2147483648</span>);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;passed&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>avg</span>(a: <span style=color:#66d9ef>u32</span>, b: <span style=color:#66d9ef>u32</span>) -&gt; <span style=color:#66d9ef>u32</span>{
</span></span><span style=display:flex><span>    (a <span style=color:#f92672>&amp;</span> b) <span style=color:#f92672>+</span> ((a <span style=color:#f92672>^</span> b) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span> )
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=整数溢出>整数溢出</h3><p>在电脑领域里所发生的溢出条件是, 运行单项数值计算时, 当计算产生出来的结果是非常大的, 大于寄存器或存储器所能存储或表示的能力限制就会发生溢出.</p><p>在不同的编程语言中, 对待溢出通常有以下几种不同的做法:</p><ul><li>崩溃: 当溢出被侦测到时, 程序立即退出运行</li><li>忽略: 这是最普遍的作法, 忽略任何算数溢出</li></ul><p>对于溢出的处理方法, Rust 在 debug 与 release 模式下是不同的. 在 debug 模式下编译时, Rust 会检查整数溢出, 如果发生这种行为, 会导致程序在运行时终止并报出运行时错误. 而如果在 release 模式下编译时, Rust 不会对整数溢出进行检查.</p><p>要显式处理溢出, 可以使用标准库提供的一些 <code>.overflowing_*</code> 方法:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a: <span style=color:#66d9ef>u32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4294967295</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b: <span style=color:#66d9ef>u32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (r, is_overflow) <span style=color:#f92672>=</span> a.overflowing_add(b);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;r={} is_overflow={}&#34;</span>, r, is_overflow);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=元组>元组</h3><p>元组是将多个具有各种类型的值组合成一个复合类型的通用方法，元组有固定长度，一旦声明，他们的大小就不能增长或者收缩。</p><p>通过在括号内写一个逗号分隔的值列表来创建一个元组，元组中的每个位置都有一个类型，元组中不同值的类型不必相同.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a: <span style=color:#66d9ef>i32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b: <span style=color:#66d9ef>char</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;A&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建一个元组
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> mytuple: (<span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>char</span>) <span style=color:#f92672>=</span> (a, b);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 从元组中读取一个值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;.0={:?}&#34;</span>, mytuple.<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;.1={:?}&#34;</span>, mytuple.<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 解封装
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> (c, d) <span style=color:#f92672>=</span> mytuple;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;c={} d={}&#34;</span>, c, d);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=数组>数组</h3><p>rust中另一种具有多个数据集合的方法是数组，与元组不同，数据的每一个元素的类型都必须相同，rust中的数组不同于其他的语言，rust的数据足有固定的长度。</p><p>数组的下标以0开始，同时rust存在越界检查。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建数组, [i32; 3] 是数组的类型提示, 表示元素的类型是 i32, 共有 3 个元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> myarray: [<span style=color:#66d9ef>i32</span>; <span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 根据索引获取一个值, 数组下标从 0 开始
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;{:?}&#34;</span>, myarray[<span style=color:#ae81ff>1</span>]);  <span style=color:#75715e>//:?也可以不写
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 索引不能越界
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;{:?}&#34;</span>, myarray[<span style=color:#ae81ff>3</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果数组的每个元素都有相同的值, 我们还可以简化数组的初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> myarray: [<span style=color:#66d9ef>i32</span>; <span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>; <span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;{:?}&#34;</span>, myarray[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=切片类型>切片类型</h3><p>切片类型是对一个数组(包括固定大小数组和动态数组)的引用片段, 有利于安全有效地访问数组的一部分, 而不需要拷贝数组或数组中的内容. 切片在编译的时候其长度是未知的, 在底层实现上, 一个切片保存着两个 uszie 成员, 第一个 usize 成员指向切片起始位置的指针, 第二个 usize 成员表示切片长度.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> arr: [<span style=color:#66d9ef>i32</span>; <span style=color:#ae81ff>5</span>] <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> slice <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>arr[<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>3</span>]; <span style=color:#75715e>// 取前 3 个元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;slice[0]={}, len={}&#34;</span>, slice[<span style=color:#ae81ff>0</span>], slice.len());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=结构体>结构体</h3><p>结构体是多种不同数据类型的组合. 它与元组类似, 但区别在于我们可以为每个成员命名. 可以使用 struct 关键字创建三种类型的结构:</p><ul><li>元组结构</li><li>经典的 C 结构</li><li>无字段的单元结构</li></ul><p>结构体使用驼峰命名.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// 元组结构
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Pair</span>(<span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>f32</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 经典的 C 结构
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    name: String,
</span></span><span style=display:flex><span>    age: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 无字段的单元结构, 在泛型中较为常用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Unit</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 结构体的实例化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> pair <span style=color:#f92672>=</span> Pair(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>4.2</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> person <span style=color:#f92672>=</span> Persion {
</span></span><span style=display:flex><span>        name: String::from(<span style=color:#e6db74>&#34;jack&#34;</span>),
</span></span><span style=display:flex><span>        age: <span style=color:#ae81ff>21</span>,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> unit <span style=color:#f92672>=</span> Unit;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 从结构体中获取成员
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;{}&#34;</span>, pari.<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;{}&#34;</span>, persion.name);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=枚举>枚举</h3><p>enum关键字可以创建枚举类型，枚举类型包含了取值的全部可能情况，在rust中有多种不同形式的枚举写法。</p><h4 id=无参数的枚举>无参数的枚举</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Planet</span> {
</span></span><span style=display:flex><span>    Mars,
</span></span><span style=display:flex><span>    Earth,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的代码定义了枚举Planet包含了两个值Mars和Earth.</p><h4 id=带枚举值的枚举>带枚举值的枚举</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Color</span> {
</span></span><span style=display:flex><span>    Red <span style=color:#f92672>=</span> OxffOOOO,
</span></span><span style=display:flex><span>    Green <span style=color:#f92672>=</span> OxOOffOO,
</span></span><span style=display:flex><span>    Blue <span style=color:#f92672>=</span> OxOOOOff,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=带参数的枚举>带参数的枚举</h4><p>支持带类型参数的枚举</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>IpAddr</span> {
</span></span><span style=display:flex><span>    IPv4(<span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>),
</span></span><span style=display:flex><span>    IPv6(<span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=模式匹配>模式匹配</h4><p>枚举通常与 match 模式匹配一起使用.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>IpAddr</span> {
</span></span><span style=display:flex><span>    IPv4(<span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>),
</span></span><span style=display:flex><span>    IPv6(<span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> localhost: <span style=color:#a6e22e>IpAddr</span> <span style=color:#f92672>=</span> IpAddr::IPv4(<span style=color:#ae81ff>127</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> localhost {
</span></span><span style=display:flex><span>        IpAddr::IPv4(a, b, c, d) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            println!(<span style=color:#e6db74>&#34;{} {} {} {}&#34;</span>, a, b, c, d);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        _ <span style=color:#f92672>=&gt;</span> {} <span style=color:#75715e>// 任何非 IPv4 类型走这条分支
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=println>println</h3><p><code>println!</code> 用于将数据打印到标准输出, 且在数据末尾自动带上换行符. 在所有平台上, 换行符都是换行符(没有额外的回车符).</p><p>使用 <code>println!</code> 用于程序的正常输出, 使用 <code>eprintln!</code> 打印错误或者进度条. 前者数据被写入 stdout, 后者则是 stderr. <code>println!</code> 宏常用的格式化语法如下所示:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// `{}` 会被变量内容替换, 这是最常见的一种用法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;{}&#34;</span>, <span style=color:#ae81ff>42</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 可以使用额外的位置参数.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;{0}{1}{0}&#34;</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 使用命名参数.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;name={name} age={age}&#34;</span>, name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;jack&#34;</span>, age<span style=color:#f92672>=</span><span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 可以在 `:` 后面指定特殊的格式.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;{} of {:b} people know binary, the other half don&#39;t&#34;</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 可以按指定宽度来右对齐文本.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;{number:&gt;width$}&#34;</span>, number<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, width<span style=color:#f92672>=</span><span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 在数字左边补 0.下面语句输出 &#34;000001&#34;.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;{number:&gt;0width$}&#34;</span>, number<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, width<span style=color:#f92672>=</span><span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// println! 会检查使用到的参数数量是否正确.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;My name is {0}, {1} {0}&#34;</span>, <span style=color:#e6db74>&#34;Bond&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 编译将会报错, 请补上漏掉的参数：&#34;James&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h4 id=类型转换>类型转换</h4><p>Rust 是一门强类型语言, 因此不支持隐式类型转换. Rust 为了实现类型之间的转换提供了几种不同的方法.</p><h5 id=as语法>as语法</h5><p>as 语法是 Rust 最基础的一种类型转换方法, 它通常用于整数, 浮点数和字符数据之间的类型转换.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a: <span style=color:#66d9ef>i8</span> <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> a <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u8</span>;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;a={} b={}&#34;</span>, a, b);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>数值转换的语义是:</p><ul><li>两个相同大小的整型之间(例如: i32->u32)的转换是一个 no-op</li><li>从一个大的整型转换为一个小的整型(例如: u32->u8)会截断</li><li>从一个小的整型转换为一个大的整型(例如: u8->u32)会<ul><li>如果源类型是无符号的会补零(zero-extend)</li><li>如果源类型是有符号的会符号(sign-extend)</li></ul></li><li>从一个浮点转换为一个整型会向 0 舍入</li><li>从一个整型转换为一个浮点会产生整型的浮点表示，如有必要会舍入(未指定舍入策略)</li><li>从 f32 转换为 f64 是完美无缺的</li><li>从 f64 转换为 f32 会产生最接近的可能值(未指定舍入策略)</li></ul><h5 id=transmute>transmute</h5><p>as 只允许安全的转换, 例如会拒绝例如尝试将 4 个字节转换为一个 u32:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span><span style=color:#66d9ef>u8</span>, <span style=color:#ae81ff>0</span><span style=color:#66d9ef>u8</span>, <span style=color:#ae81ff>0</span><span style=color:#66d9ef>u8</span>, <span style=color:#ae81ff>0</span><span style=color:#66d9ef>u8</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> a <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>; <span style=color:#75715e>// Four u8s makes a u32.
</span></span></span></code></pre></div><p>但是我们知道 u32 在内存中表示为 4 个连续的 u8, 因此我们可以使用一种危险的方法: 告诉编译器直接以另一种数据类型对待内存中的数据. 编译器会无条件信任你. 但是, 除非你知道自己在干什么, 不然并不推荐使用 transmute. 要使用 transmute, 需要将代码写入 <code>unsafe</code> 块中.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span><span style=color:#66d9ef>u8</span>, <span style=color:#ae81ff>1</span><span style=color:#66d9ef>u8</span>, <span style=color:#ae81ff>0</span><span style=color:#66d9ef>u8</span>, <span style=color:#ae81ff>0</span><span style=color:#66d9ef>u8</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> mem::transmute::<span style=color:#f92672>&lt;</span>[<span style=color:#66d9ef>u8</span>; <span style=color:#ae81ff>4</span>], <span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;</span>(a);
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;{}&#34;</span>, b); <span style=color:#75715e>// 256
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Or, more concisely:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> c: <span style=color:#66d9ef>u32</span> <span style=color:#f92672>=</span> mem::transmute(a);
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;{}&#34;</span>, c); <span style=color:#75715e>// 256
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><div class=post-tags><a href=/tags/rust>rust</a>
<a href=/tags/%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80>编程语言</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-nav><div class="post-nav-next post-nav-item"></div><div class="post-nav-prev post-nav-item"><a href=/posts/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/ rel=prev title=数组链表栈和队列>数组链表栈和队列
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>random-zhu</span></div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"busuanzi":{"pageview":true},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"https://random-zhu.github.com","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"statis":{"enable":false,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.4.1","waline":{"cfg":{"comment":false,"emoji":false,"imguploader":false,"pageview":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":false,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.ddd00d37a7edf66fc7b7681f876c06e19ef8059b7dbd3f81c6de15c62a1d7d74.js defer></script>
<script type=text/javascript src=/js/math.min.a6ada19a368d85dad9ead2040d86ae561a867fafef89391d1aa2aa5909366509.js defer></script></body></html>